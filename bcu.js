const Discord = require('discord.js');

const client = new Discord.Client();

client.on('ready', () => {

  console.log('---------------');

  console.log(' Gold Bot Is OnMusic')

  console.log('---------------')

  client.user.setStatus("Online")

 client.user.setActivity(" Crystal Server",{type: 'PLAYING'})

});

var prefix= "$" 

client.on('message', message => {

   if(!message.channel.guild) return;

if(message.content.startsWith( prefix+'bc')) {

if(!message.channel.guild) return message.channel.send('**Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª**').then(m => m.delete(5000));

if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**Ù„Ù„Ø£Ø³Ù Ù„Ø§ ØªÙ…ØªÙ„Ùƒ ØµÙ„Ø§Ø­ÙŠØ©** `ADMINISTRATOR`' );

let args = message.content.split(" ").join(" ").slice(2 + prefix.length);

let BcList = new Discord.RichEmbed()

.setThumbnail(message.author.avatarURL)

.setAuthor(`Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ ${args}`)

.setDescription(`Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª Ø¨Ù€ Ø§Ù…Ø¨Ø¯ ğŸ“\nØ¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª Ø¨Ø¯ÙˆÙ† Ø§Ù…Ø¨Ø¯âœ \nÙ„Ø¯ÙŠÙƒ Ø¯Ù‚ÙŠÙ‚Ù‡ Ù„Ù„Ø£Ø®ØªÙŠØ§Ø± Ù‚Ø¨Ù„ Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª\nÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø¶Ø§ÙØ© Ø§Ø³Ù… Ø§Ù„Ø³ÙŠØ±ÙØ± ÙÙŠ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª Ø¹Ù† Ø·Ø±ÙŠÙ‚ ÙƒØªØ§Ø¨Ø© <server>\nÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø¶Ø§ÙØ© Ø§Ø³Ù… Ø§Ù„Ù…Ø±Ø³Ù„ ÙÙŠ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª Ø¹Ù† Ø·Ø±ÙŠÙ‚ ÙƒØªØ§ÙŠØ© <by>\nÙŠÙ…ÙƒÙ†Ùƒ Ù…Ù†Ø´Ù†Ø© Ø§Ù„Ø¹Ø¶Ùˆ ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ Ø¹Ù† Ø·Ø±ÙŠÙ‚ ÙƒØªØ§Ø¨Ø© <user>`)

if (!args) return message.reply('**ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙƒØªØ§Ø¨Ø© ÙƒÙ„Ù…Ø© Ø§Ùˆ Ø¬Ù…Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª**');message.channel.send(BcList).then(msg => {

msg.react('ğŸ“')

.then(() => msg.react('âœ'))

.then(() =>msg.react('ğŸ“'))

 

let EmbedBcFilter = (reaction, user) => reaction.emoji.name === 'ğŸ“' && user.id === message.author.id;

let NormalBcFilter = (reaction, user) => reaction.emoji.name === 'âœ' && user.id === message.author.id;

 

let EmbedBc = msg.createReactionCollector(EmbedBcFilter, { time: 60000 });

let NormalBc = msg.createReactionCollector(NormalBcFilter, { time: 60000 });

 

 

EmbedBc.on("collect", r => {

 

message.channel.send(`:ballot_box_with_check: ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ Ø¨Ù†Ø¬Ø§Ø­`).then(m => m.delete(5000));

message.guild.members.forEach(m => {

let EmbedRep = args.replace('<server>' ,message.guild.name).replace('<user>', m).replace('<by>', `${message.author.username}#${message.author.discriminator}`)

var bc = new

Discord.RichEmbed()

.setColor('RANDOM')

.setDescription(EmbedRep)

.setThumbnail(message.author.avatarURL)

m.send({ embed: bc })

msg.delete();

})

})

NormalBc.on("collect", r => {

  message.channel.send(`:ballot_box_with_check: ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ Ø¨Ù†Ø¬Ø§Ø­`).then(m => m.delete(5000));

message.guild.members.forEach(m => {

let NormalRep = args.replace('<server>' ,message.guild.name).replace('<user>', m).replace('<by>', `${message.author.username}#${message.author.discriminator}`)

m.send(NormalRep);

msg.delete();

})

})

})

}

});

const adminprefix = "$vip";//by ,$ ReBeL Ø¡ , ğŸ”•#4777 'CODES SERVER'

const devs = ['470500980342128650'];//by ,$ ReBeL Ø¡ , ğŸ”•#4777 'CODES SERVER'

client.on('message', message => {//by ,$ ReBeL Ø¡ , ğŸ”•#4777 'CODES SERVER'

  var argresult = message.content.split(` `).slice(1).join(' ');//by ,$ ReBeL Ø¡ , ğŸ”•#4777 'CODES SERVER'

    if (!devs.includes(message.author.id)) return;//by ,$ ReBeL Ø¡ , ğŸ”•#4777 'CODES SERVER'

    

if (message.content.startsWith(adminprefix + 'setgame')) {//by ,$ ReBeL Ø¡ , ğŸ”•#4777 'CODES SERVER'

  client.user.setGame(argresult);

    message.channel.sendMessage(`**${argresult} ØªÙ… ØªØºÙŠÙŠØ± Ø¨Ù„Ø§ÙŠÙ†Ù‚ Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰ **`)

} else 

  if (message.content.startsWith(adminprefix + 'setname')) {

client.user.setUsername(argresult).then

    message.channel.sendMessage(`**${argresult}** : ØªÙ… ØªØºÙŠÙŠØ± Ø£Ø³Ù… Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰`)

return message.reply("**Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± Ø§Ù„Ø§Ø³Ù… ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ù†ØªØ¸Ø¢Ø± Ù„Ù…Ø¯Ø© Ø³Ø§Ø¹ØªÙŠÙ† . **");

} else

  if (message.content.startsWith(adminprefix + 'setavatar')) {

client.user.setAvatar(argresult);

  message.channel.sendMessage(`**${argresult}** : ØªÙ… ØªØºÙŠØ± ØµÙˆØ±Ø© Ø§Ù„Ø¨ÙˆØª`);

      } else     

if (message.content.startsWith(adminprefix + 'setT')) {

  client.user.setGame(argresult, "https://www.twitch.tv/idk");

    message.channel.sendMessage(`**ØªÙ… ØªØºÙŠÙŠØ± ØªÙˆÙŠØªØ´ Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰  ${argresult}**`)

}

});



const misaka = new Set();

    client.on('message', async msg => {

  if(msg.content.startsWith("Ø±Ø§Ø¨Ø·")) {

  if (misaka.has(msg.author.id)) {

    let misakaemb = new Discord.RichEmbed()

    .setDescription(`ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± 24 Ø³Ø§Ø¹Ù‡!`)

    .setColor(`RED`)

    return msg.channel.send(misakaemb).then(message => {

     message.delete(10000) 

    })

    

    }

    misaka.add(msg.author.id);

  

   msg.channel.createInvite({

        thing: true,

        maxUses: 5,

        maxAge: 86400,

  }).then(invite =>

   msg.author.sendMessage(`

         <@${msg.author.id}> 

         **maxUses: 5 **

         ${invite.url}`)

  )

    msg.channel.send(`**:link: Invite Linke Sent In DM Successfully**`)

  }

    setTimeout(() => {

    },86400000);

    })          

            

            

           

           

           

client.on('message',message =>{

    

    if(message.content.startsWith(prefix + 'top')) {

  message.guild.fetchInvites().then(i =>{

  var invites = [];

   

  i.forEach(inv =>{

    var [invs,i]=[{},null];

     

    if(inv.maxUses){

        invs[inv.code] =+ inv.uses+"/"+inv.maxUses;

    }else{

        invs[inv.code] =+ inv.uses;

    }

        invites.push(`invite: ${inv.url} inviter: ${inv.inviter} \`${invs[inv.code]}\`;`);

   

  });

  var embed = new Discord.RichEmbed()

  .setColor("#000000")

  .setDescription(`${invites.join(`\n`)+'\n\n**By:** '+message.author}`)

  

           message.channel.send({ embed: embed });

   

  });

   

    }

  });

  

  

  

  

  

  

  

  

client.on('message', message => {

if (message.content.startsWith('#inv-info')) {

let oi = message.mentions.users.first() ? message.mentions.users.first().id : message.author.id ; 

  let img = message.mentions.users.first() ? message.mentions.users.first().username : message.author.username;

  let imagemm = message.mentions.users.first() ? message.mentions.users.first().avatarURL : message.author.avatarURL

  message.guild.fetchInvites().then(invs => {

    let member = client.guilds.get(message.guild.id).members.get(oi);

    let personalInvites = invs.filter(i => i.inviter.id === oi);

    let urll = invs.filter(i => i.inviter.id === oi);

    let link = urll.reduce((p , v) => v.url +` , Total de membros recrutados no convite: ${v.uses}.\n`+ p, `\nServidor: ${message.guild.name} \n `);

    let inviteCount = personalInvites.reduce((p, v) => v.uses + p, 0);

   let exec = personalInvites.reduce((p, v) => v.inviter);

 let possibleInvites = [['Total de membros recrutados:']];

possibleInvites.push([inviteCount, exec]);

        let user = message.mentions.users.first() || message.author;

        let mem = message.guild.member(user);

        let millisJoined = new Date().getTime() - mem.joinedAt.getTime();

        let daysJoined = millisJoined / 1000 / 60 / 60 / 24;

const alpha = new Discord.RichEmbed()

.setAuthor(img)

.addField('ğŸ† Invite Infos',  `\n\nâ–º Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ø¯Ø¹ÙˆØ© Ù…Ø§ Ù…Ø¬Ù…ÙˆØ¹Ù‡ \`\`${Number(inviteCount)}\`\` Ø¹Ø¶Ùˆ.\n\nâ–º Ù„Ù‚Ø¯ Ø§Ù†Ø¶Ù…Ù…Øª Ù„Ø³Ø±ÙØ± Ù…Ù†Ø¯\`${daysJoined.toFixed(0)}\`ÙŠÙˆÙ… .\n\nâ–º Ù„Ù‚Ø¯ Ø§Ù†Ø¶Ù…Ù…Øª Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø¹ÙˆØ©\`${exec}\``,true)

.setThumbnail(imagemm)

.setColor(0x4959e9);

message.channel.send(alpha);

});

};

  });

       

const fs = require('fs');

const moment = require('moment');

const jimp = require('jimp');

const Canvas = require('canvas');

 

client.on('guildMemberAdd', member => {

     const welcomer =  member.guild.channels.find('name', 'crystal');

const w = ['./w1.png'];

 

         let Image = Canvas.Image,

            canvas = new Canvas(400, 200),

            ctx = canvas.getContext('2d');

        fs.readFile(`${w[Math.floor(Math.random() * w.length)]}`, function (err, Background) {

            if (err) return console.log(err);

            let BG = Canvas.Image;

            let ground = new Image;

            ground.src = Background;

            ctx.drawImage(ground, 0, 0, 400, 200);

             

         

 

                let url = member.user.displayAvatarURL.endsWith(".webp") ? member.user.displayAvatarURL.slice(100) + ".png" : member.user.displayAvatarURL;

                jimp.read(url, (err, ava) => {

                    if (err) return console.log(err);

                    ava.getBuffer(jimp.MIME_PNG, (err, buf) => {

                        if (err) return console.log(err);

                       

                        ctx.font = "bold 12px Arial";

                        ctx.fontSize = '20px';

                        ctx.fillStyle = "#f1f1f1";

                        ctx.textAlign = "center";

                        ctx.fillText(`welcome to crystal`, 300, 130);

                       

                        ctx.font = "bold 12px Arial";

                        ctx.fontSize = '20px';

                        ctx.fillStyle = "#f1f1f1";

                        ctx.textAlign = "center";

                        ctx.fillText(member.user.username, 200, 150);

 

                let Avatar = Canvas.Image;

                              let ava = new Avatar;

                              ava.src = buf;

                              ctx.beginPath();

                              ctx.arc(77, 101, 62, 0, Math.PI*2);

                              ctx.stroke();

                                 ctx.clip();

                                 ctx.drawImage(ava, 13, 38, 128, 126);  

                         

               

                             

welcomer.sendFile(canvas.toBuffer())

 

 

 

     

     

                    }  )  

     

                   

 

})

      });                    

});

var dat = JSON.parse("{}");

function forEachObject(obj, func) {

    Object.keys(obj).forEach(function (key) { func(key, obj[key]) });

}

client.on("ready", () => {

    var guild;

    while (!guild)

        guild = client.guilds.get("470637918222811138");

    guild.fetchInvites().then((data) => {

        data.forEach((Invite, key, map) => {

            var Inv = Invite.code;

            dat[Inv] = Invite.uses;

        });

    });

});

 

 

 

client.on("guildMemberAdd", (member) => {

    let channel = member.guild.channels.get("484818214665322496");

    if (!channel) {

        console.log("!the channel id it's not correct");

        return;

    }

    if (member.id == client.user.id) {

        return;

    }

    console.log('-');

    var guild;

    while (!guild)

        guild = client.guilds.get("470637918222811138");

    guild.fetchInvites().then((data) => {

        data.forEach((Invite, key, map) => {

            var Inv = Invite.code;

            if (dat[Inv])

                if (dat[Inv] < Invite.uses) {

                    setTimeout(function() {

 channel.send(`**invited by** ${Invite.inviter} `) ;

                    },1500);

 }

            dat[Inv] = Invite.uses;

       

       });

    });

});

            
var user = {};

var warn = {};

var user = {};

var warn = {};

client.on('message', function(message) {

    	 if (!message.channel.guild) return;let muteRole1 = message.guild.roles.find("name", "Muted");

     if (!muteRole1) return;

  if (message.author.id == client.user.id) return;

  if(JSON.stringify(user).indexOf(message.author.id) == -1) {

    user[message.author.id] = message.createdTimestamp;

    return;

  } else {

    if (Date.now() - user[message.author.id] < 695){

              message.author.delete

      if (JSON.stringify(warn).indexOf(message.author.id) == -1) {

        warn[message.author.id] = 1;

      } else {

        warn[message.author.id]++;

        message.author.delete

      }

      if (warn[message.author.id] < 8) {

        message.author.delete

      }

      delete user[message.author.id];

              message.author.delete

    } else {

      delete user[message.author.id];

              message.author.delete

    }

  }

  if (warn[message.author.id] == 8) {		   

     if (!message.channel.guild) return;

             message.author.delete

let muteRole1 = message.guild.roles.find("name", "Muted");

     if (!muteRole1) return;

    var guild = message.channel.guild;

          var currentTime = new Date(),

                   Year = currentTime.getFullYear(),

            Month = currentTime.getMonth() + 1,

            Day = currentTime.getDate(),

hours = currentTime.getHours() + 3 ,

            minutes = currentTime.getMinutes()+1,

            seconds = currentTime.getSeconds();

           if (!message.channel.guild) return;

     if (!muteRole1) return;

    var guild = message.channel.guild;

    message.guild.members.get(message.author.id).addRole(muteRole1);

    

     var msg;

        msg = parseInt();

      

      message.channel.fetchMessages({limit: msg}).then(messages => message.channel.bulkDelete(messages)).catch(console.error);

delete warn[message.author.id];

    delete user[message.author.id];

	const embed500 = new Discord.RichEmbed()

     .setTitle(`Ø§Ù„Ù…Ø±Ø³Ù„ ${message.author.username}#${message.author.discriminator} `)

      .setDescription(":white_check_mark:  | `Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø³Ø¨Ø§Ù…`\n\nØ§Ù„Ø§Ø³Ù…:\n"+`${message.author.username}#${message.author.discriminator}`+"\nØ§Ù„Ø¹Ù‚ÙˆØ¨Ø©:\nÙ…ÙŠÙˆØª Ø´Ø§Øª\n")

          .setFooter("Crystal")

      .setColor("c91616")

    message.channel.send(embed500)

    	const embed20 = new Discord.RichEmbed()

      .setTitle(":scales: | ØªÙ…Øª Ù…Ø¹Ø§Ù‚Ø¨ØªÙƒ")

      .setDescription(`**Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ù…Ø®Ø§Ù„ÙØ© Ù‚ÙˆØ§Ù†ÙŠÙ† Ø§Ù„Ø³ÙŠØ±ÙØ±**\n\nØªÙ…Øª Ù…Ø¹Ø§Ù‚Ø¨ØªÙƒ Ù…Ù† Ù‚Ø¨Ù„ :\nL-\nÙ†ÙˆØ¹ Ø§Ù„Ø¹Ù‚ÙˆØ¨Ø©:\nÙ…ÙŠÙˆØª Ø´Ø§Øª\nØªØ§Ø±ÙŠØ® Ø§Ù„Ø¹Ù‚ÙˆØ¨Ø©:\n`+ Year + "/" + Month + "/" + Day +', '+hours +'-' +minutes+'-'+seconds+"\n \n \n`ÙÙŠ Ø­Ø§Ù„ ÙƒØ§Ù†Øª Ø§Ù„Ø¹Ù‚ÙˆØ¨Ø© Ø¨Ø§Ù„ØºÙ„Ø·, ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø§Ø¯Ø§Ø±Ø©`")

          .setFooter("Crystal")

      .setColor("c91616")

    

     message.author.send(embed20)

  

  }

});




            
client.login(process.env.BOT_TOKEN); 
